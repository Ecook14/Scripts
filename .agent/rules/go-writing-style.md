---
trigger: model_decision
description: While writing Golang script
---

1. Zero-Dependency MinimalismThe biggest advantage of Go is the single static binary. A senior admin avoids third-party packages unless absolutely necessary.Stick to the Standard Library: Use net/http, os/exec, and encoding/json.Static Linking: Ensure the binary is statically linked (CGO_ENABLED=0) so it runs on a "distroless" container or a bare-bones Alpine install without needing glibc.2. Never Ignore an errorIn Bash, a script might continue after a failed cd. In Go, thatâ€™s a cardinal sin.Check Every err: Every file open, every command execution, and every network call must have an if err != nil block.Wrap Errors: Use fmt.Errorf("context: %w", err) to provide a breadcrumb trail of where the failure happened.Fail Fast: If a configuration file is missing, the script should exit immediately with a non-zero status code rather than trying to use defaults that might be dangerous.3. Graceful Signal HandlingServers are dynamic. Processes get restarted or killed. A senior admin ensures the script cleans up after itself.Listen for SIGINT/SIGTERM: Use the os/signal package to catch Ctrl+C or a systemd stop command.Cleanup: Close file descriptors, remove temporary files, and release network locks before the process actually exits.4. Context for EverythingSystem tasks (like backups or API calls) can hang. A senior admin never starts a task without a timeout.context.WithTimeout: Wrap every long-running operation in a context. If the disk is hanging or the network is latent, the script shouldn't sit there forever consuming a process slot.Propagation: Pass the ctx variable down to every function that performs I/O.5. Structured Logging vs. Standard OutputA script's output should be readable by both humans and machines (like Splunk or ELK).Stdout for Data: Use fmt.Println only for the actual "result" of the script (e.g., a list of IDs).Stderr for Logs: Use the log package or a structured logger (like slog in Go 1.21+) to send operational info to stderr.JSON Logging: If the script is running in a production cluster, output logs in JSON format for easy parsing.6. Defensive Command ExecutionWhen using os/exec to run shell commands, treats input as "guilty until proven innocent."Avoid Shell Spawning: Use exec.Command("name", "arg1", "arg2") rather than passing a single string to a shell, which prevents command injection.Absolute Paths: Define the path to binaries (e.g., /usr/bin/ip instead of just ip) to avoid PATH-hijacking vulnerabilities.7. Resource ConstraintsSystem scripts should be "invisible" to the OS's performance metrics.Worker Pools: If processing 1,000 logs, don't spawn 1,000 goroutines at once. Use a worker pool to limit concurrency and prevent memory spikes.Streaming I/O: Use io.Reader and io.Writer (like bufio) to process large files line-by-line instead of loading a 2GB log file into memory.Comparison: Junior vs. Senior ApproachFeatureJunior Admin (The "Bash" Habit)Senior Admin (The "Go" Way)Errors_ = function() (Ignored)if err != nil { ... } (Handled)Concurrencygo func() for everythingsync.WaitGroup & Worker PoolsBinariesRelies on system librariesCGO_ENABLED=0 static binariesConfigHardcoded pathsEnvironment variables or flagsExecutionshell.Run("rm -rf " + path)os.RemoveAll(path)